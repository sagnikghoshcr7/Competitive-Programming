import java.io.*;
import java.util.*;

public class Template15 {

	static Scanner sc = new Scanner(System.in);
	static PrintWriter pw = new PrintWriter(System.out);

	static int calc(int x, int y, int d) {
		
		return (y-x+d-1)/d;
	}
	
	static int calc2(int x, int y, int d) {	
		return (y-x+d-1)/d;
	}
	
	public static void main(String[] args) throws Exception {
		int t = sc.nextInt();
		while (t-- > 0) {
			int n = sc.nextInt();
			int m = sc.nextInt();
			int d = sc.nextInt();
			int[] a = new int[m+2];
			a[0] = 1;
			a[m+1] = n+1;
			for(int i = 1; i<=m; i++) a[i] = sc.nextInt();
			int ans = 0;
			int cnt = 0;
			long sum = 0;
			for(int i = 1; i<=m; i++) {
				int res = (calc(a[i-1], a[i], d) + calc(a[i], a[i+1], d)) - calc(a[i-1], a[i+1], d);
				if(res > ans) {
					ans = res;
					cnt = 1;
				}else if(res == ans) {
					cnt++;
				}
			}
			for(int i = 1; i<=m+1; i++) {
				sum += calc2(a[i-1],a[i],d);
			}
			pw.print(sum-ans + " ");
			pw.println(cnt);
			
		}
		pw.close();
	}

	static long[] ExtendedGCD(long a, long b) {
		if (b == 0) {
			return new long[] { 1, 0 };
		}
		long[] next = ExtendedGCD(b, a % b); // solution of the next call

		long x1 = next[0];
		long y1 = next[1];

		long[] res = new long[2];

		res[0] = y1;
		res[1] = x1 - a / b * y1;

		return res;
	}

	// next sol
	static long[] nextSol(long x, long y, long a, long b) {
		long g = gcd(a, b);
		return new long[] { x + b / g, y - a / g };
	}

	static long[] prevSol(long x, long y, long a, long b) {
		long g = gcd(a, b);
		return new long[] { x - b / g, y + a / g };
	}

	public static void merge(int[] arr, int start, int mid, int end) {
		int sz = (end - start) + 1;
		int tmp[] = new int[sz];

		int lptr = start;
		int rptr = mid;

		for (int i = 0; i < sz; i++) {
			if (lptr == mid) {
				tmp[i] = arr[rptr];
				rptr++;
			} else if (rptr > end) {
				tmp[i] = arr[lptr];
				lptr++;
			} else if (arr[rptr] < arr[lptr]) {
				tmp[i] = arr[rptr];
				rptr++;
//				inversions += mid-(lptr);
//				System.out.println(lptr + " " + rptr);
			} else {
				tmp[i] = arr[lptr];
				lptr++;
			}
		}

		for (int i = 0; i < sz; i++) {
			arr[start + i] = tmp[i];
		}

	}

	public static void sort(int[] arr, int start, int end) {
		if (start == end)
			return;

		int mid = (start + end) / 2;

		sort(arr, start, mid);
		sort(arr, mid + 1, end);

		merge(arr, start, mid + 1, end);
	}

	public static void sort(int[] arr) {
		sort(arr, 0, arr.length - 1);
	}

	static int N = (int) 1e6;

	static ArrayList<Integer> primes; // Generated by sieve algorithm;
	static int[] prime = new int[N + 1];

	public static void sieve() { // Complexity O(Nlog(log(N));
		primes = new ArrayList<>();
		Arrays.fill(prime, 1);
		prime[0] = prime[1] = 0;
		for (int i = 2; i <= N; i++) {
			if (prime[i] == 1) {
				for (long j = 1l * i * i; j <= N; j += i)
					prime[(int) j] = 0;
				primes.add(i);
			}
		}
	}

	public static ArrayList<Integer> primeFactors(int N) { // Complexity O(sqrt(N) / ln (sqrt(N)));
		ArrayList<Integer> factors = new ArrayList<>();
		int PF_idx = 0;
		int PF = primes.get(PF_idx); // primes has been populated by sieve
		while (PF * PF <= N) { // stop at sqrt(N); N can get smaller
			int pow = 0;
			while (N % PF == 0) {
				N /= PF;
				pow++;
			} // remove PF
			if (pow != 0) {
				factors.add(PF);
			}
			PF = primes.get(++PF_idx); // only consider primes!

		}
		if (N > 1) {
			factors.add(N);
		} // special case if N is a prime
		return factors; // if N does not fit in 32-bit integer and is a prime
	}

	public static int countPrimeFactors(int N) { // Complexity O(sqrt(N) / ln (sqrt(N)));
		int cnt = 0;
		int PF_idx = 0;
		int PF = primes.get(PF_idx); // primes has been populated by sieve
		while (PF * PF <= N) { // stop at sqrt(N); N can get smaller
			while (N % PF == 0) {
				N /= PF;
				cnt++;
			} // remove PF
			PF = primes.get(++PF_idx); // only consider primes!

		}
		if (N > 1) {
			cnt++;
		} // special case if N is a prime
		return cnt; // if N does not fit in 32-bit integer and is a prime
	}

	static ArrayList<Integer> div = new ArrayList<>();

	static void dfs(ArrayList<Integer> fac, int i, int n, int x) {
		if (i == n) {
			div.add(x);
			return;
		}
		dfs(fac, i + 1, n, x);
		dfs(fac, i + 1, n, x * fac.get(i));
	}

	static class Pair implements Comparable<Pair> {
		int first;
		int second;

		public Pair(int first, int second) {
			this.first = first;
			this.second = second;
		}

		public int compareTo(Pair p) {
			if (first != p.first)
				return Integer.compare(first, p.first);
			else if (second != p.second)
				return Integer.compare(second, p.second);
			else
				return 0;

		}

		public String toString() {
			return "(" + first + ", " + second + ")";
		}

	}

	static class SegmentTree {
		long[] sg;
		int N;

		public SegmentTree(int N) { // there is no input array , initially empty
			this.N = N;
			sg = new long[N << 1];
		}

		public SegmentTree(long[] arr) { // the input array is power of 2 and 1-indexed
			this.N = arr.length - 1;
			sg = new long[N << 1];
			build(1, 1, N, arr);
		}

		public long f(long x, long y) {
			return x + y;
		}

		public void build(int node, int start, int end, long[] array) {
			if (start == end) {
				sg[node] = array[start];
			} else {
				int leftChild = node << 1, rightChild = leftChild | 1;
				int mid = start + end >> 1;
				build(leftChild, start, mid, array);
				build(rightChild, mid + 1, end, array);
				sg[node] = f(sg[leftChild], sg[rightChild]);
			}
		}

		public void updatePoint(int idx, long val) { // update = set
			idx += N - 1;
			sg[idx] = val;
			while (idx > 1) {
				idx >>= 1;
				sg[idx] = f(sg[idx << 1], sg[(idx << 1) | 1]);
			}
		}

		public void updatePoint(int idx) { // update = set
			idx += N - 1;
			sg[idx] ^= 1;
			while (idx > 1) {
				idx >>= 1;
				sg[idx] = f(sg[idx << 1], sg[(idx << 1) | 1]);
			}
		}

		public long query(int l, int r) {
			return query(1, 1, N, l, r);
		}

		public long query(int node, int start, int end, int l, int r) {
			if (start >= l && end <= r)
				return sg[node];
			if (start > r || end < l)
				return 0; // value does not affect the answer
			int mid = start + end >> 1;
			int leftChild = node << 1, rightChild = leftChild | 1;
			return f(query(leftChild, start, mid, l, r), query(rightChild, mid + 1, end, l, r));
		}
	}

	static int[] mods;
	static int[] counts;

	public static ArrayList<Integer> divisors(int x) {
		ArrayList<Integer> a = new ArrayList<>();
		for (int i = 1; i < Math.sqrt(x); i++) {
			if (x % i == 0) {
				a.add(i);
				a.add(x / i);
			}
		}
		if ((int) Math.sqrt(x) * (int) Math.sqrt(x) == x)
			a.add((int) Math.sqrt(x));
		return a;
	}

	public static long int_sqrt(long x) {
		long ans = 0;
		for (long k = 1L << 30; k != 0; k /= 2) {
			if ((ans + k) * (ans + k) <= x) {
				ans += k;
			}
		}
		return ans;
	}

	public static boolean isPrime(int n) {
		if (n <= 1) {
			return false;
		}
		if (n <= 3) {
			return true;
		}
		if (n % 2 == 0 || n % 3 == 0) {
			return false;
		}
		for (int i = 5; i * i <= n; i += 6) {
			if (n % i == 0 || n % (i + 2) == 0) {
				return false;
			}
		}
		return true;
	}

	public static long gcd(long a, long b) {
		if (b == 0)
			return a;
		return gcd(b, a % b);
	}

	public static long lcm(long a, long b) {
		return a / gcd(a, b) * b;
	}

	static long fastPower(long a, long e) // O(log e)
	{
//		a %= mod;
		long res = 1l;
		while (e > 0) {
			if ((e & 1) == 1)
				res = (res * a); // % mod;
			a = (a * a); // % mod;
			e >>= 1l;
		}
		return res;// % mod;
	}

	static long Pow(long a, long n) {
		if (n == 0)
			return 1;
		long res = 1;
		if ((n & 1) == 1)
			res *= a;
		long pow = Pow(a, n / 2) % mod;
		res *= pow;
		res %= mod;
		res *= pow;
		res %= mod;
		return res;
	}

	static long modInverse(long b) {
		return fastPower(b, mod - 2) % mod;
	}

	public static long fastMod(String N, long mod) {
		long r = 0;
		String s = N + "";
		for (int i = 0; i < N.length(); i++) {
			r *= 10;
			r += N.charAt(i) - '0';
			r %= mod;
		}
		r %= mod;
		return r;
	}

	static void facc(int n) {
		fac = new long[n + 1];
		inv = new long[n + 1];
		fac[0] = 1;
		for (int i = 1; i <= n; i++) {
			fac[i] = (fac[i - 1] * i) % mod;
		}
		inv[0] = 1;
		inv[1] = 1;
		for (int i = 2; i <= n; i++)
			inv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;
		for (int i = 2; i <= n; i++) {
			inv[i] *= inv[i - 1];
			inv[i] %= mod;
		}

	}

	static long nc(int n, int r) {
		if (n < r)
			return 0;

		return ((fac[n] * inv[n - r]) % mod * inv[r]) % mod;
	}

	static long np(int n, int r) {
		return (nc(n, r) * fac[r]) % mod;
	}

	static long fac[];
	static long inv[];

	static long mod = (long) 1e9 + 7;

	static long[][] matrixMul(long[][] a, long[][] b) {
		if (a[0].length != b.length) {
			return null;
		}

		long[][] res = new long[a.length][b[0].length];
		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < b[0].length; j++) {
				for (int k = 0; k < a[0].length; k++) {
					res[i][j] += a[i][k] * b[k][j];
					res[i][j] %= mod;
				}
			}
		}
		return res;
	}

	static long[][] matrixPower(long[][] a, long n) {
		long[][] res = new long[a.length][a.length]; // Identity matrix
		/*
		 * 1 0 0 0 1 0 0 0 1
		 */
		for (int i = 0; i < a.length; i++) {
			res[i][i] = 1;
		}

		while (n != 0) {
			if ((n & 1) == 1) {
				res = matrixMul(res, a);
			}
			a = matrixMul(a, a);
			n >>= 1;
		}
		return res;
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder("0");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder("0");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		long[] readArray(int n) throws IOException {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		int[] nextIntArray(int n) throws IOException {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

	}

}